# Decimal 
## 2의 보수법
<div style="text-align:center" markdown="1">

![two's complement](./img/2.jpg "two's complement")

</DIV>

2의 보수는 각 비트를 반전시킨 후에 1을 더한 것
1의 보수를 사용 했을 경우 위의 사진과 같이 +0, -0이 생기는 문제가 발생.
- 유일한 0을 만들기 위해 
- 또한, Accumulator 작성에 유리함
>Example
>- 1의 보수 : 4 + (-3) 의 경우
>   - 0100 + 1011 = 1111?
>- 2의 보수 : 4 + (-3) 의 경우
>   - 0100 + 1101 = (1)0001

****
## 데이터 모델

int 는 몇 바이트 일까?
long 은 몇 바이트 일까?
범위를 좁혀서 64-bit Linux 에서 int, long 은 몇 바이트 일까? 

데이터 타입은 항상 일정하지는 않다
long 의 경우, 윈도우즈 에서는 4바이트 이고, 리눅스에서는 8바이트 이다.
플랫폼 별로 데이터 모델이 다르기 때문.

|Data Model | char |short | int | long | long long | pointer | Operating System |
|---|---|---|---|---|---|---|---|
| ILP32 | 8 | 16 | 32 | 32 | 64 | 32 | Microsoft Windows (x86-64 and IA-64) using Visual C++; and MinGW, Most Unix and Unix-like systems |
| LLP64, IL32P64 | 8 | 16 | 32 | 32 | 64 | 64 | Microsoft Windows (x86-64 and IA-64) using Visual C++; and MinGW  |
| LP64, I32LP64 | 8 | 16 | 32 | 64 | 64 | 64 | Most Unix and Unix-like systems, e.g., Solaris, Linux, BSD, macOS. Windows when using Cygwin; z/OS |
| ILP64 | 8 | 16 | 64 | 64 | 64 | 64 | HAL Computer Systems port of Solaris to the SPARC64 |
| SILP64 | 8 | 64 | 64 | 64 | 64 | 64 | Classic UNICOS (versus UNICOS/mp, etc.) |

x86 32비트 시스템에서는 윈도우, 리눅스 모두 ILP32모델을 사용했지만 64비트로 넘어오면서 차이가 발생

ILP32 의 경우 int, long, pointer가 32비트 라는 뜻
LP64의 경우 long, pointer가 64비트 LLP64의 경우 long, long, pointer가 64비트라는 의미
특수한(SILP64) 경우가 아닌 char, short, long long은 그 크기가 (8, 16, 64)로 일정
int, long, pointer는 모델에 따라 달라지므로 주의

****

##부동소수점

###고정소수점과 부동소수점
- 고정소수점은 소수점의 위치를 고정 하는것
- 부동소수점이란 실수를 표현할 때 소수점의 위치를 고정 하지 않는것
  
고정 소수점의 경우 한정된 비트에 고정소수점의 경우 정수부분과 소수부분을 나누어 표현해야 할 경우 고정소수점이 나타낼 수 있는 범위가 한정된다.
예를 들어 123.456 의 경우 정수부분 123과 소수부분 456을 나누어서 표현해야 함

부동소수점의 경우 123.456을 123456이라는 유효숫자부와 3이라는 소수점 위치를 통해서 고정소수보다 훨씬 넓은 범위의 수를 표현 할 수 있음

### 부동소수점 계산
정수는 '2의 보수법' 을 통해 2진법으로 표기 소수는?

- 실수를 2진법으로 표현하는 법
> 10진수 -9.6875를 2진법으로 나타내는 방법
> 
> 정수 9와 소수 0.67875 나누어 계산
> 정수 9는 2진수로 1001
> 소수부분의 경우 2를 곱해서 정수 부분을 취하면 된다.
> 
> ![소수 2진법 변환](./img/decimal2-1.png "소수 2진법 변환")
> 
> 소수 부분에 2를 곱한 후, 결과가 1을 넘을 경우 1을 빼고 각 단계 정수 부분을 얻어 낸다.
> 일반적인 소수의 경우 실수는 무한히 반복되므로 적당한 개수의 유효숫자만 취하게 된다.
> -9.6785를 2진법으로 표현하면 -1001.1011 이 됨

### 부동소수점 구조
-9.6875는 2진법으로 -1001.1011으로 표현된다
-1001.1011을 저장하는 방법은?
부동소수점을 표현하기 위하여 정규화 과정을 거치는데, 지수를 이용하여 실수를 표현하는 것.
-1001.1011를 정규화할 경우 -1.0011011 * 2³ 이 된다.
정규화란 정수부를 1로 맞추고, 소수점의 위치를 적절하게 변경하는 것